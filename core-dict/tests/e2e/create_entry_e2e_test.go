package e2e_test

import (
	"bytes"
	"crypto/sha256"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"testing"
	"time"

	"github.com/google/uuid"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"github.com/lbpay-lab/core-dict/tests/testhelpers"
)

// EntryRequest represents the API request to create an entry
type EntryRequest struct {
	KeyType   string `json:"keyType"`
	KeyValue  string `json:"keyValue"`
	AccountID string `json:"accountId"`
	ISPB      string `json:"ispb"`
	UserID    string `json:"userId"`
}

// EntryResponse represents the API response
type EntryResponse struct {
	ID        string    `json:"id"`
	KeyType   string    `json:"keyType"`
	KeyValue  string    `json:"keyValue"`
	AccountID string    `json:"accountId"`
	ISPB      string    `json:"ispb"`
	Status    string    `json:"status"`
	CreatedAt time.Time `json:"createdAt"`
}

func TestE2E_CreateEntry_CPF_Success_WithBacen_Simulation(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping E2E test in short mode")
	}

	env := testhelpers.SetupE2ETest(t)

	// Arrange
	req := EntryRequest{
		KeyType:   "CPF",
		KeyValue:  "12345678901",
		AccountID: uuid.NewString(),
		ISPB:      "12345678",
		UserID:    "e2e-test-user",
	}

	reqBody, err := json.Marshal(req)
	require.NoError(t, err)

	// Act - Call Core-Dict API to create entry
	resp, err := env.HTTPClient.Post(
		env.CoreURL+"/api/v1/entries",
		"application/json",
		bytes.NewBuffer(reqBody),
	)
	require.NoError(t, err)
	defer resp.Body.Close()

	// Assert - Entry created
	assert.Equal(t, http.StatusCreated, resp.StatusCode, "Should create entry successfully")

	var entry EntryResponse
	body, _ := io.ReadAll(resp.Body)
	err = json.Unmarshal(body, &entry)
	require.NoError(t, err)

	assert.NotEmpty(t, entry.ID)
	assert.Equal(t, "CPF", entry.KeyType)
	assert.Equal(t, req.KeyValue, entry.KeyValue)
	assert.Equal(t, "ACTIVE", entry.Status)

	// Verify: Event propagated through system
	// In real E2E, would check Connect → Bridge → Bacen (mock)
	// Here we verify entry is queryable
	time.Sleep(500 * time.Millisecond)

	getResp, err := env.HTTPClient.Get(env.CoreURL + "/api/v1/entries/" + entry.ID)
	require.NoError(t, err)
	defer getResp.Body.Close()

	assert.Equal(t, http.StatusOK, getResp.StatusCode)

	var retrievedEntry EntryResponse
	body, _ = io.ReadAll(getResp.Body)
	err = json.Unmarshal(body, &retrievedEntry)
	require.NoError(t, err)

	assert.Equal(t, entry.ID, retrievedEntry.ID)
	assert.Equal(t, entry.KeyType, retrievedEntry.KeyType)
}

func TestE2E_CreateEntry_EVP_Generated_Success(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping E2E test in short mode")
	}

	env := testhelpers.SetupE2ETest(t)

	// Arrange - EVP is generated by the system
	req := EntryRequest{
		KeyType:   "EVP",
		KeyValue:  "", // Empty, should be generated
		AccountID: uuid.NewString(),
		ISPB:      "12345678",
		UserID:    "e2e-test-user",
	}

	reqBody, err := json.Marshal(req)
	require.NoError(t, err)

	// Act
	resp, err := env.HTTPClient.Post(
		env.CoreURL+"/api/v1/entries",
		"application/json",
		bytes.NewBuffer(reqBody),
	)
	require.NoError(t, err)
	defer resp.Body.Close()

	// Assert
	assert.Equal(t, http.StatusCreated, resp.StatusCode)

	var entry EntryResponse
	body, _ := io.ReadAll(resp.Body)
	err = json.Unmarshal(body, &entry)
	require.NoError(t, err)

	assert.NotEmpty(t, entry.ID)
	assert.Equal(t, "EVP", entry.KeyType)
	assert.NotEmpty(t, entry.KeyValue, "EVP should be generated")
	assert.Len(t, entry.KeyValue, 36, "EVP should be UUID format") // UUID length with dashes
}

func TestE2E_CreateEntry_Duplicate_GlobalCheck_Connect_Bridge_Bacen(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping E2E test in short mode")
	}

	env := testhelpers.SetupE2ETest(t)

	// Arrange - Create first entry
	cpf := "98765432109"
	req1 := EntryRequest{
		KeyType:   "CPF",
		KeyValue:  cpf,
		AccountID: uuid.NewString(),
		ISPB:      "12345678",
		UserID:    "e2e-test-user",
	}

	reqBody1, err := json.Marshal(req1)
	require.NoError(t, err)

	// Act - Create first entry
	resp1, err := env.HTTPClient.Post(
		env.CoreURL+"/api/v1/entries",
		"application/json",
		bytes.NewBuffer(reqBody1),
	)
	require.NoError(t, err)
	defer resp1.Body.Close()

	assert.Equal(t, http.StatusCreated, resp1.StatusCode)

	var entry1 EntryResponse
	body1, _ := io.ReadAll(resp1.Body)
	err = json.Unmarshal(body1, &entry1)
	require.NoError(t, err)

	// Wait for event propagation (Connect → Bridge → Bacen)
	time.Sleep(1 * time.Second)

	// Act - Try to create duplicate entry (same CPF)
	req2 := EntryRequest{
		KeyType:   "CPF",
		KeyValue:  cpf, // Same CPF
		AccountID: uuid.NewString(),
		ISPB:      "87654321", // Different ISPB
		UserID:    "e2e-test-user",
	}

	reqBody2, err := json.Marshal(req2)
	require.NoError(t, err)

	resp2, err := env.HTTPClient.Post(
		env.CoreURL+"/api/v1/entries",
		"application/json",
		bytes.NewBuffer(reqBody2),
	)
	require.NoError(t, err)
	defer resp2.Body.Close()

	// Assert - Should detect duplicate
	// Duplicate check happens via Connect → Bridge → Bacen
	assert.Equal(t, http.StatusConflict, resp2.StatusCode, "Should detect duplicate key")

	body2, _ := io.ReadAll(resp2.Body)
	var errorResp map[string]interface{}
	err = json.Unmarshal(body2, &errorResp)
	require.NoError(t, err)

	assert.Contains(t, errorResp["error"], "duplicate", "Error should mention duplicate")
}

func TestE2E_CreateEntry_MaxKeys_CPF_5_Exceeded(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping E2E test in short mode")
	}

	env := testhelpers.SetupE2ETest(t)

	// Arrange - Create account with 5 keys (max for CPF)
	accountID := uuid.NewString()
	ispb := "12345678"

	// Create 5 keys
	for i := 0; i < 5; i++ {
		req := EntryRequest{
			KeyType:   "PHONE",
			KeyValue:  fmt.Sprintf("+551199999999%d", i),
			AccountID: accountID,
			ISPB:      ispb,
			UserID:    "e2e-test-user",
		}

		reqBody, err := json.Marshal(req)
		require.NoError(t, err)

		resp, err := env.HTTPClient.Post(
			env.CoreURL+"/api/v1/entries",
			"application/json",
			bytes.NewBuffer(reqBody),
		)
		require.NoError(t, err)
		defer resp.Body.Close()

		assert.Equal(t, http.StatusCreated, resp.StatusCode, "Should create key %d", i+1)
	}

	// Act - Try to create 6th key
	req6 := EntryRequest{
		KeyType:   "PHONE",
		KeyValue:  "+55119999999910",
		AccountID: accountID,
		ISPB:      ispb,
		UserID:    "e2e-test-user",
	}

	reqBody6, err := json.Marshal(req6)
	require.NoError(t, err)

	resp6, err := env.HTTPClient.Post(
		env.CoreURL+"/api/v1/entries",
		"application/json",
		bytes.NewBuffer(reqBody6),
	)
	require.NoError(t, err)
	defer resp6.Body.Close()

	// Assert - Should reject (max 5 keys per CPF)
	assert.Equal(t, http.StatusBadRequest, resp6.StatusCode, "Should reject 6th key")

	body6, _ := io.ReadAll(resp6.Body)
	var errorResp map[string]interface{}
	err = json.Unmarshal(body6, &errorResp)
	require.NoError(t, err)

	assert.Contains(t, errorResp["error"], "maximum", "Error should mention maximum keys")
}

func TestE2E_CreateEntry_LGPD_Hash_SHA256(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping E2E test in short mode")
	}

	env := testhelpers.SetupE2ETest(t)

	// Arrange - Create entry with sensitive data (CPF)
	cpf := "11122233344"
	req := EntryRequest{
		KeyType:   "CPF",
		KeyValue:  cpf,
		AccountID: uuid.NewString(),
		ISPB:      "12345678",
		UserID:    "e2e-test-user",
	}

	reqBody, err := json.Marshal(req)
	require.NoError(t, err)

	// Act - Create entry
	resp, err := env.HTTPClient.Post(
		env.CoreURL+"/api/v1/entries",
		"application/json",
		bytes.NewBuffer(reqBody),
	)
	require.NoError(t, err)
	defer resp.Body.Close()

	assert.Equal(t, http.StatusCreated, resp.StatusCode)

	var entry EntryResponse
	body, _ := io.ReadAll(resp.Body)
	err = json.Unmarshal(body, &entry)
	require.NoError(t, err)

	// Assert - Verify LGPD compliance
	// In real implementation, sensitive data should be hashed/encrypted
	// For this test, we verify the CPF is stored correctly

	// Calculate expected hash (for audit/verification)
	expectedHash := fmt.Sprintf("%x", sha256.Sum256([]byte(cpf)))
	t.Logf("CPF hash (SHA256): %s", expectedHash)

	// Verify entry returned
	assert.Equal(t, cpf, entry.KeyValue, "KeyValue should match (not hashed in response)")

	// In real system, would verify:
	// 1. Database stores hashed version
	// 2. Audit logs contain hashed CPF
	// 3. Sensitive data is encrypted at rest

	// Query audit log endpoint (if exists)
	auditResp, err := env.HTTPClient.Get(env.CoreURL + "/api/v1/audit/" + entry.ID)
	if err == nil {
		defer auditResp.Body.Close()
		if auditResp.StatusCode == http.StatusOK {
			auditBody, _ := io.ReadAll(auditResp.Body)
			t.Logf("Audit log response: %s", string(auditBody))

			// Verify audit log doesn't expose raw CPF
			assert.NotContains(t, string(auditBody), cpf, "Audit log should not expose raw CPF")
		}
	}

	// Verify entry is retrievable
	getResp, err := env.HTTPClient.Get(env.CoreURL + "/api/v1/entries/" + entry.ID)
	require.NoError(t, err)
	defer getResp.Body.Close()

	assert.Equal(t, http.StatusOK, getResp.StatusCode)

	var retrievedEntry EntryResponse
	getBody, _ := io.ReadAll(getResp.Body)
	err = json.Unmarshal(getBody, &retrievedEntry)
	require.NoError(t, err)

	assert.Equal(t, entry.ID, retrievedEntry.ID)
	assert.Equal(t, cpf, retrievedEntry.KeyValue)
}

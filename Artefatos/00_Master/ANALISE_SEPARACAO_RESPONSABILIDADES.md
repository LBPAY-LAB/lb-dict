# An√°lise: Separa√ß√£o de Responsabilidades Core-Dict vs Conn-Dict
**Data**: 2025-10-27 18:30 BRT
**Autor**: Claude Sonnet 4.5 (Architect Analysis)
**Vers√£o**: 1.0
**Status**: An√°lise Arquitetural Cr√≠tica

---

## üéØ PERGUNTA ESSENCIAL

> **"Workflows de neg√≥cio complexos (como Reivindica√ß√µes) devem estar no Core-Dict ou Conn-Dict?"**

### Resposta Direta

**‚úÖ WORKFLOWS DE NEG√ìCIO ‚Üí CORE-DICT**
**‚úÖ INTEGRA√á√ÉO T√âCNICA (connection pool, retry, circuit breaker) ‚Üí CONN-DICT**

**Por qu√™?** Vou detalhar cada camada arquitetural abaixo.

---

## üìê PRINC√çPIOS ARQUITETURAIS (Fundamento da Decis√£o)

### 1. **Separation of Concerns** (SoC)

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    CAMADAS DO SISTEMA                        ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                               ‚îÇ
‚îÇ  üè¢ CORE-DICT (Business Layer)                              ‚îÇ
‚îÇ     ‚îú‚îÄ L√≥gica de Neg√≥cio PIX/DICT                           ‚îÇ
‚îÇ     ‚îú‚îÄ Regras Regulat√≥rias Bacen                            ‚îÇ
‚îÇ     ‚îú‚îÄ Workflows Complexos (Claim, Portability)             ‚îÇ
‚îÇ     ‚îú‚îÄ Valida√ß√µes de Dom√≠nio                                ‚îÇ
‚îÇ     ‚îî‚îÄ Orquestra√ß√£o de Processos                            ‚îÇ
‚îÇ                                                               ‚îÇ
‚îÇ  üîå CONN-DICT (Integration Layer)                           ‚îÇ
‚îÇ     ‚îú‚îÄ Adapta√ß√£o gRPC/Pulsar                                ‚îÇ
‚îÇ     ‚îú‚îÄ Connection Pool Management                            ‚îÇ
‚îÇ     ‚îú‚îÄ Retry Dur√°vel (Temporal)                             ‚îÇ
‚îÇ     ‚îú‚îÄ Circuit Breaker                                       ‚îÇ
‚îÇ     ‚îî‚îÄ Transforma√ß√£o de Protocolos                          ‚îÇ
‚îÇ                                                               ‚îÇ
‚îÇ  üåâ CONN-BRIDGE (Protocol Adapter)                          ‚îÇ
‚îÇ     ‚îú‚îÄ SOAP/XML Transformation                              ‚îÇ
‚îÇ     ‚îú‚îÄ mTLS/ICP-Brasil                                       ‚îÇ
‚îÇ     ‚îú‚îÄ Assinatura Digital                                    ‚îÇ
‚îÇ     ‚îî‚îÄ Bacen DICT API Calls                                 ‚îÇ
‚îÇ                                                               ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### 2. **Domain-Driven Design** (DDD)

**Bounded Contexts**:
- **Core-Dict**: Contexto de Dom√≠nio PIX (Business)
- **Conn-Dict**: Contexto de Integra√ß√£o (Technical)
- **Conn-Bridge**: Contexto de Adapta√ß√£o de Protocolo (Technical)

### 3. **Hexagonal Architecture** (Ports & Adapters)

```
Core-Dict (Hex√°gono Central)
    ‚Üì Port: gRPC/Pulsar
Conn-Dict (Adapter Externo)
    ‚Üì Port: gRPC
Conn-Bridge (Adapter Externo)
    ‚Üì Port: SOAP/HTTPS
Bacen DICT API
```

---

## üè¢ CORE-DICT: L√≥gica de Neg√≥cio (Business Layer)

### RESPONSABILIDADES CORE-DICT

#### 1. **Workflows de Neg√≥cio Complexos** ‚úÖ CORE-DICT

##### Exemplo: ClaimWorkflow (Reivindica√ß√£o de Chave)

**Complexidade de Neg√≥cio**:
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ           ClaimWorkflow (30 dias dur√°vel)                    ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                               ‚îÇ
‚îÇ  1. User A reivindica chave de User B                        ‚îÇ
‚îÇ     ‚Üì                                                         ‚îÇ
‚îÇ  2. CORE valida: User A √© dono original?                     ‚îÇ
‚îÇ     ‚îú‚îÄ Consulta hist√≥rico transacional                       ‚îÇ
‚îÇ     ‚îú‚îÄ Valida documentos                                     ‚îÇ
‚îÇ     ‚îî‚îÄ Verifica se chave foi roubada/clonada                 ‚îÇ
‚îÇ     ‚Üì                                                         ‚îÇ
‚îÇ  3. CORE cria Claim (status: OPEN)                           ‚îÇ
‚îÇ     ‚Üì                                                         ‚îÇ
‚îÇ  4. CORE notifica User B (propriet√°rio atual)                ‚îÇ
‚îÇ     ‚îú‚îÄ Email                                                  ‚îÇ
‚îÇ     ‚îú‚îÄ Push notification                                     ‚îÇ
‚îÇ     ‚îî‚îÄ SMS                                                    ‚îÇ
‚îÇ     ‚Üì                                                         ‚îÇ
‚îÇ  5. CORE aguarda 7 dias (Bacen rule)                         ‚îÇ
‚îÇ     ‚îú‚îÄ Timer Temporal (dur√°vel)                              ‚îÇ
‚îÇ     ‚îî‚îÄ Se User B n√£o responder ‚Üí auto-accept                 ‚îÇ
‚îÇ     ‚Üì                                                         ‚îÇ
‚îÇ  6. CORE decide (business rule):                             ‚îÇ
‚îÇ     ‚îú‚îÄ User B confirmou? ‚Üí CONFIRMED                         ‚îÇ
‚îÇ     ‚îú‚îÄ User B rejeitou? ‚Üí DENIED                             ‚îÇ
‚îÇ     ‚îú‚îÄ Timeout (7 dias)? ‚Üí AUTO-CONFIRMED                    ‚îÇ
‚îÇ     ‚îî‚îÄ Evid√™ncias de fraude? ‚Üí DENIED                        ‚îÇ
‚îÇ     ‚Üì                                                         ‚îÇ
‚îÇ  7. CORE executa a√ß√£o:                                        ‚îÇ
‚îÇ     ‚îú‚îÄ CONFIRMED: Transfer chave para User A                 ‚îÇ
‚îÇ     ‚îú‚îÄ DENIED: Mant√©m chave com User B                       ‚îÇ
‚îÇ     ‚îî‚îÄ Atualiza status em PostgreSQL                         ‚îÇ
‚îÇ     ‚Üì                                                         ‚îÇ
‚îÇ  8. CORE notifica resultado a ambos usu√°rios                 ‚îÇ
‚îÇ     ‚Üì                                                         ‚îÇ
‚îÇ  9. CORE registra audit log (compliance Bacen)               ‚îÇ
‚îÇ                                                               ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Por que no CORE-DICT?**
- ‚úÖ **Regras de neg√≥cio complexas** (valida√ß√£o de propriedade, hist√≥rico, fraude)
- ‚úÖ **Decis√µes baseadas em contexto** (hist√≥rico transacional, perfil usu√°rio)
- ‚úÖ **Orquestra√ß√£o multi-step** (notificar ‚Üí aguardar ‚Üí decidir ‚Üí executar)
- ‚úÖ **Compliance Bacen** (audit logs, rastreabilidade, reports regulat√≥rios)
- ‚úÖ **Integra√ß√£o com outros dom√≠nios** (Fraud Detection, User Profile, Transaction History)

**Por que N√ÉO no CONN-DICT?**
- ‚ùå Conn-Dict n√£o tem contexto de neg√≥cio
- ‚ùå Conn-Dict n√£o conhece regras Bacen complexas
- ‚ùå Conn-Dict n√£o acessa outros dom√≠nios (Fraud, User, etc)
- ‚ùå Separa√ß√£o de concerns violada

---

#### 2. **Valida√ß√µes de Dom√≠nio** ‚úÖ CORE-DICT

**Exemplos**:

```go
// CORE-DICT: Valida√ß√£o de regra de neg√≥cio
func (s *EntryService) CreateEntry(cmd CreateEntryCommand) error {
    // 1. Valida√ß√£o de limite (regra Bacen: max 5 chaves por conta)
    count, _ := s.entryRepo.CountByAccountID(cmd.AccountID)
    if count >= 5 {
        return ErrMaxKeysExceeded // Business rule
    }

    // 2. Valida√ß√£o de duplicata (regra Bacen: chave √∫nica por participante)
    exists, _ := s.entryRepo.ExistsByKey(cmd.KeyValue)
    if exists {
        return ErrKeyAlreadyExists // Business rule
    }

    // 3. Valida√ß√£o de conta ativa (regra de neg√≥cio)
    account, _ := s.accountService.GetAccount(cmd.AccountID)
    if account.Status != "ACTIVE" {
        return ErrAccountInactive // Business rule
    }

    // 4. Valida√ß√£o de ownership (regra de neg√≥cio)
    if cmd.KeyType == CPF && cmd.KeyValue != account.OwnerCPF {
        return ErrKeyOwnershipMismatch // Business rule
    }

    // 5. Valida√ß√£o anti-fraude (regra de neg√≥cio)
    fraudScore, _ := s.fraudService.CheckFraud(cmd)
    if fraudScore > 0.8 {
        return ErrSuspiciousFraud // Business rule
    }

    // Ap√≥s TODAS as valida√ß√µes de neg√≥cio ‚Üí chama Conn-Dict
    return s.connectClient.CreateEntry(ctx, protoReq)
}
```

**Por que no CORE-DICT?**
- ‚úÖ Valida√ß√µes dependem de contexto de neg√≥cio
- ‚úÖ Integra√ß√£o com m√∫ltiplos servi√ßos (Account, Fraud, User)
- ‚úÖ Regras Bacen complexas (limite, ownership, duplicata)

---

#### 3. **Orquestra√ß√£o de Processos** ‚úÖ CORE-DICT

**Exemplo: Portabilidade de Chave**

```go
// CORE-DICT: Orquestra√ß√£o complexa
func (s *PortabilityService) InitiatePortability(req InitiatePortabilityRequest) error {
    // 1. Validar elegibilidade (business rule)
    if !s.isEligibleForPortability(req.Key) {
        return ErrNotEligible
    }

    // 2. Verificar hist√≥rico de portabilidades (business rule: max 2 por ano)
    count, _ := s.portabilityRepo.CountLastYear(req.Key)
    if count >= 2 {
        return ErrMaxPortabilityExceeded
    }

    // 3. Consultar institui√ß√£o destino (valida√ß√£o)
    destinationBank, _ := s.bankService.GetBank(req.DestinationISPB)
    if !destinationBank.AcceptsPortability {
        return ErrDestinationNotSupported
    }

    // 4. Criar portability request (state)
    portability := s.portabilityRepo.Create(req)

    // 5. Notificar banco origem (business process)
    s.notificationService.NotifyOriginBank(portability)

    // 6. Chamar Conn-Dict para executar no Bacen (integration)
    err := s.connectClient.InitiatePortability(ctx, protoReq)

    // 7. Atualizar status baseado em resposta (state management)
    if err != nil {
        portability.Status = "FAILED"
        portability.FailureReason = err.Error()
    } else {
        portability.Status = "PENDING_APPROVAL"
    }
    s.portabilityRepo.Update(portability)

    // 8. Registrar audit log (compliance)
    s.auditService.LogPortabilityInitiated(portability)

    return nil
}
```

**Por que no CORE-DICT?**
- ‚úÖ M√∫ltiplos passos com l√≥gica de neg√≥cio
- ‚úÖ Valida√ß√µes complexas (elegibilidade, hist√≥rico, limites)
- ‚úÖ Integra√ß√£o com m√∫ltiplos servi√ßos
- ‚úÖ State management (PostgreSQL pr√≥prio)
- ‚úÖ Audit logs e compliance

---

#### 4. **Gest√£o de Estado de Neg√≥cio** ‚úÖ CORE-DICT

```go
// CORE-DICT: Estado de neg√≥cio rico
type Entry struct {
    EntryID           string
    KeyValue          string
    KeyType           KeyType
    Status            EntryStatus // Business state

    // Business context
    AccountID         string
    OwnerName         string
    OwnerCPF          string

    // Business history
    CreatedBy         string
    CreatedAt         time.Time
    UpdatedAt         time.Time
    DeletedAt         *time.Time

    // Business tracking
    ClaimHistory      []Claim
    PortabilityHistory []Portability
    AuditLogs         []AuditLog

    // Business rules
    MaxClaims         int // Regra: max 3 claims por chave
    IsLocked          bool // Regra: lock durante portabilidade
}
```

**Por que no CORE-DICT?**
- ‚úÖ Estado rico com contexto de neg√≥cio
- ‚úÖ Hist√≥rico para decis√µes futuras
- ‚úÖ Audit trail para compliance

---

## üîå CONN-DICT: Camada de Integra√ß√£o (Integration Layer)

### RESPONSABILIDADES CONN-DICT

#### 1. **Connection Pool Management** ‚úÖ CONN-DICT

```go
// CONN-DICT: Gerenciamento t√©cnico de conex√µes
type BridgeClientPool struct {
    clients       []*BridgeClient
    maxConnections int
    currentIndex  int
    mu            sync.Mutex
}

func (p *BridgeClientPool) GetClient() *BridgeClient {
    p.mu.Lock()
    defer p.mu.Unlock()

    // Round-robin load balancing
    client := p.clients[p.currentIndex]
    p.currentIndex = (p.currentIndex + 1) % len(p.clients)

    return client
}

func (p *BridgeClientPool) HealthCheck() {
    // Remove unhealthy clients
    // Add new clients if needed
    // Rebalance load
}
```

**Por que no CONN-DICT?**
- ‚úÖ Concern t√©cnico de infraestrutura
- ‚úÖ N√£o tem contexto de neg√≥cio
- ‚úÖ Reutiliz√°vel para qualquer tipo de request
- ‚úÖ Core-Dict n√£o deve saber de connection pools

---

#### 2. **Retry Dur√°vel com Temporal** ‚úÖ CONN-DICT

```go
// CONN-DICT: Retry t√©cnico (n√£o business logic)
func (w *BridgeCallActivity) Execute(ctx context.Context, req BridgeRequest) error {
    // Retry com backoff exponencial
    retryPolicy := &temporal.RetryPolicy{
        InitialInterval:    1 * time.Second,
        BackoffCoefficient: 2.0,
        MaximumInterval:    10 * time.Second,
        MaximumAttempts:    5,
    }

    // Se Bridge retornar erro HTTP (503, 500, 429) ‚Üí retry
    // Se Bridge retornar erro de neg√≥cio (404, 400) ‚Üí N√ÉO retry
    return w.bridgeClient.Call(ctx, req)
}
```

**Por que no CONN-DICT?**
- ‚úÖ Retry √© concern t√©cnico de infraestrutura
- ‚úÖ N√£o depende de regras de neg√≥cio
- ‚úÖ Core-Dict n√£o deve gerenciar retry HTTP

**MAS ATEN√á√ÉO**: Workflow de NEG√ìCIO (ClaimWorkflow) fica no CORE!

---

#### 3. **Circuit Breaker** ‚úÖ CONN-DICT

```go
// CONN-DICT: Prote√ß√£o contra falhas em cascata
type CircuitBreaker struct {
    breaker *gobreaker.CircuitBreaker
}

func (cb *CircuitBreaker) CallBridge(ctx context.Context, req BridgeRequest) error {
    // Se Bridge estiver falhando muito ‚Üí OPEN circuit
    // Evita sobrecarregar Bacen
    // Retorna erro r√°pido para Core-Dict
    result, err := cb.breaker.Execute(func() (interface{}, error) {
        return cb.bridgeClient.Call(ctx, req)
    })

    if err != nil {
        // Core-Dict recebe erro e decide o que fazer (business decision)
        return err
    }

    return result
}
```

**Por que no CONN-DICT?**
- ‚úÖ Prote√ß√£o de infraestrutura
- ‚úÖ N√£o depende de l√≥gica de neg√≥cio
- ‚úÖ Reutiliz√°vel para todos os tipos de request

---

#### 4. **Transforma√ß√£o de Protocolo** ‚úÖ CONN-DICT

```go
// CONN-DICT: Adapta√ß√£o t√©cnica de protocolos
func (s *ConnectService) CreateEntry(ctx context.Context, req *corepb.CreateEntryRequest) (*corepb.CreateEntryResponse, error) {
    // 1. Converte Core proto ‚Üí Connect proto
    connectReq := s.convertCoreToConnect(req)

    // 2. Envia para Bridge via gRPC
    bridgeResp, err := s.bridgeClient.CreateEntry(ctx, connectReq)

    // 3. Converte Bridge proto ‚Üí Core proto
    coreResp := s.convertBridgeToCore(bridgeResp)

    return coreResp, nil
}
```

**Por que no CONN-DICT?**
- ‚úÖ Transforma√ß√£o t√©cnica de mensagens
- ‚úÖ Core-Dict n√£o deve conhecer detalhes de proto do Bridge
- ‚úÖ Separa√ß√£o de concerns (Core n√£o sabe de Bridge)

---

#### 5. **Pulsar Event Handling** ‚úÖ CONN-DICT

```go
// CONN-DICT: Consumir eventos ass√≠ncronos do Core
func (c *PulsarConsumer) HandleEntryCreatedEvent(event EntryCreatedEvent) {
    // 1. Deserializa evento Pulsar
    req := s.convertEventToRequest(event)

    // 2. Chama Bridge (s√≠ncrono)
    err := s.bridgeClient.CreateEntry(ctx, req)

    // 3. Publica resultado de volta para Core (Pulsar)
    if err != nil {
        s.pulsarProducer.Publish("dict.entry.created.failed", FailedEvent{...})
    } else {
        s.pulsarProducer.Publish("dict.entry.created.success", SuccessEvent{...})
    }

    // 4. Ack ou Nack (Pulsar concern)
    if err != nil {
        return err // Nack ‚Üí retry
    }
    return nil // Ack
}
```

**Por que no CONN-DICT?**
- ‚úÖ Infraestrutura de mensageria
- ‚úÖ Core-Dict n√£o deve conhecer detalhes de Pulsar
- ‚úÖ Conn-Dict √© o "adaptador" entre Core e Bacen

---

## üåâ CONN-BRIDGE: Adaptador de Protocolo (Protocol Adapter)

### RESPONSABILIDADES CONN-BRIDGE

#### 1. **SOAP/XML Transformation** ‚úÖ CONN-BRIDGE

```go
// CONN-BRIDGE: Transforma√ß√£o SOAP/XML (concern t√©cnico)
func (b *BridgeService) CreateEntry(ctx context.Context, req *bridgepb.CreateEntryRequest) (*bridgepb.CreateEntryResponse, error) {
    // 1. Proto ‚Üí XML
    xmlReq := b.converter.ProtoToXML(req)

    // 2. XML ‚Üí SOAP envelope
    soapEnvelope := b.soapBuilder.BuildEnvelope(xmlReq)

    // 3. Assinar XML (ICP-Brasil A3)
    signedSOAP := b.xmlSigner.Sign(soapEnvelope)

    // 4. POST HTTPS + mTLS para Bacen
    httpResp, err := b.httpClient.Post(bacenURL, signedSOAP)

    // 5. Parse SOAP response
    xmlResp := b.soapParser.ParseResponse(httpResp)

    // 6. XML ‚Üí Proto
    protoResp := b.converter.XMLToProto(xmlResp)

    return protoResp, nil
}
```

**Por que no CONN-BRIDGE?**
- ‚úÖ Transforma√ß√£o t√©cnica de protocolo (gRPC ‚Üî SOAP)
- ‚úÖ Core e Connect n√£o devem conhecer SOAP/XML
- ‚úÖ Bridge √© o √∫nico que "fala" com Bacen

---

## üîç AN√ÅLISE: Onde Ficam os Workflows?

### ‚ùå ERRADO: Workflow de Neg√≥cio no CONN-DICT

```go
// ‚ùå ERRADO: ClaimWorkflow no CONN-DICT
// Conn-Dict N√ÉO deve ter l√≥gica de neg√≥cio!

func (c *ConnectService) CreateClaim(ctx context.Context, req *CreateClaimRequest) error {
    // ‚ùå ERRO: Valida√ß√£o de neg√≥cio no Conn-Dict
    if req.ClaimerISPB == req.OwnerISPB {
        return ErrSameParticipant // Business rule ‚Üí deveria estar no Core!
    }

    // ‚ùå ERRO: Consulta de hist√≥rico de neg√≥cio
    claimHistory := c.claimRepo.GetHistory(req.Key)
    if len(claimHistory) >= 3 {
        return ErrMaxClaimsExceeded // Business rule ‚Üí deveria estar no Core!
    }

    // ‚ùå ERRO: Temporal Workflow de NEG√ìCIO no Conn-Dict
    workflowID := "claim-" + req.Key
    c.temporalClient.ExecuteWorkflow(ctx, workflowID, ClaimWorkflow, req)
    // ^ ERRADO! ClaimWorkflow tem l√≥gica de neg√≥cio ‚Üí deveria estar no Core!
}
```

**Por que est√° ERRADO?**
- ‚ùå Conn-Dict n√£o tem contexto de neg√≥cio
- ‚ùå Conn-Dict n√£o deveria validar regras Bacen
- ‚ùå Conn-Dict n√£o deveria consultar hist√≥rico de claims
- ‚ùå Viola√ß√£o de SoC (Separation of Concerns)
- ‚ùå Dificulta testes (business logic misturada com infra)
- ‚ùå Dificulta manuten√ß√£o (mudan√ßa de regra requer mudan√ßa em Conn-Dict)

---

### ‚úÖ CORRETO: Workflow de Neg√≥cio no CORE-DICT

```go
// ‚úÖ CORRETO: ClaimWorkflow no CORE-DICT

// CORE-DICT: Domain Service
func (s *ClaimService) CreateClaim(ctx context.Context, cmd CreateClaimCommand) error {
    // 1. Valida√ß√µes de neg√≥cio (CORE)
    if cmd.ClaimerISPB == cmd.OwnerISPB {
        return ErrSameParticipant
    }

    // 2. Consulta hist√≥rico (CORE)
    claimHistory := s.claimRepo.GetHistory(cmd.Key)
    if len(claimHistory) >= 3 {
        return ErrMaxClaimsExceeded
    }

    // 3. Valida√ß√£o anti-fraude (CORE - integra√ß√£o com outro dom√≠nio)
    fraudScore, _ := s.fraudService.CheckFraud(cmd)
    if fraudScore > 0.8 {
        return ErrSuspiciousFraud
    }

    // 4. Iniciar Temporal Workflow DE NEG√ìCIO (CORE)
    workflowID := "claim-" + cmd.Key
    err := s.temporalClient.ExecuteWorkflow(ctx, workflowID, ClaimWorkflow, cmd)

    return err
}

// CORE-DICT: Temporal Workflow (l√≥gica de neg√≥cio)
func ClaimWorkflow(ctx workflow.Context, cmd CreateClaimCommand) error {
    // 1. Criar claim (business state)
    claim := CreateClaim(cmd)
    SaveClaim(claim) // Core PostgreSQL

    // 2. Notificar propriet√°rio atual (business process)
    workflow.ExecuteActivity(ctx, NotifyOwnerActivity, claim)

    // 3. Aguardar 7 dias (business rule Bacen)
    workflow.Sleep(ctx, 7*24*time.Hour)

    // 4. Verificar se owner respondeu (business logic)
    response := GetOwnerResponse(claim.ID)

    // 5. Decidir resultado (business rule)
    if response == nil {
        // Auto-accept ap√≥s 7 dias (business rule)
        claim.Status = "AUTO-CONFIRMED"
    } else if response.Accepted {
        claim.Status = "CONFIRMED"
    } else {
        claim.Status = "DENIED"
    }

    // 6. Executar a√ß√£o no Bacen (infraestrutura - delega para Conn-Dict)
    if claim.Status == "CONFIRMED" || claim.Status == "AUTO-CONFIRMED" {
        // AQUI sim, chama Conn-Dict (infra layer)
        workflow.ExecuteActivity(ctx, CallConnectActivity, CallConnectRequest{
            Method: "CompleteClaim",
            ClaimID: claim.ID,
        })
    }

    // 7. Atualizar estado final (business state)
    SaveClaim(claim) // Core PostgreSQL

    // 8. Audit log (compliance)
    workflow.ExecuteActivity(ctx, AuditLogActivity, claim)

    return nil
}

// CORE-DICT: Activity que chama Conn-Dict (ponte infra)
func CallConnectActivity(ctx context.Context, req CallConnectRequest) error {
    // Esta Activity √© simples: apenas chama Conn-Dict
    // Conn-Dict lida com connection pool, retry, circuit breaker
    return s.connectClient.CompleteClaim(ctx, protoReq)
}
```

**Por que est√° CORRETO?**
- ‚úÖ L√≥gica de neg√≥cio (valida√ß√µes, decis√µes) no Core-Dict
- ‚úÖ Conn-Dict √© chamado APENAS para executar no Bacen (infra)
- ‚úÖ Separa√ß√£o clara: Business (Core) vs Infrastructure (Connect)
- ‚úÖ Test√°vel: Mock Conn-Dict para testar business logic
- ‚úÖ Manuten√≠vel: Mudan√ßa de regra ‚Üí apenas Core-Dict

---

## üìä TABELA RESUMO: Onde Fica O Qu√™?

| Responsabilidade | Core-Dict | Conn-Dict | Conn-Bridge | Justificativa |
|------------------|-----------|-----------|-------------|---------------|
| **Valida√ß√µes de Neg√≥cio** | ‚úÖ | ‚ùå | ‚ùå | Core tem contexto de dom√≠nio |
| **Regras Bacen Complexas** | ‚úÖ | ‚ùå | ‚ùå | Core implementa compliance |
| **Workflows Complexos (Claim, Portability)** | ‚úÖ | ‚ùå | ‚ùå | Core orquestra processos de neg√≥cio |
| **Decis√µes Baseadas em Contexto** | ‚úÖ | ‚ùå | ‚ùå | Core tem hist√≥rico, perfil, fraud detection |
| **State Management (Business)** | ‚úÖ | ‚ùå | ‚ùå | Core mant√©m estado rico de neg√≥cio |
| **Integra√ß√£o com Outros Dom√≠nios** | ‚úÖ | ‚ùå | ‚ùå | Core orquestra (Fraud, User, Account) |
| **Audit Logs (Compliance)** | ‚úÖ | ‚ùå | ‚ùå | Core respons√°vel por compliance |
| **Connection Pool Management** | ‚ùå | ‚úÖ | ‚ùå | Connect gerencia infra t√©cnica |
| **Retry Dur√°vel (Temporal)** | ‚ùå | ‚úÖ | ‚ùå | Connect faz retry t√©cnico |
| **Circuit Breaker** | ‚ùå | ‚úÖ | ‚ùå | Connect protege infra |
| **Transforma√ß√£o de Protocolo (gRPC/Pulsar)** | ‚ùå | ‚úÖ | ‚ùå | Connect adapta protocolos |
| **Pulsar Event Handling** | ‚ùå | ‚úÖ | ‚ùå | Connect consome/produz eventos |
| **Balanceamento de Carga** | ‚ùå | ‚úÖ | ‚ùå | Connect distribui requests |
| **SOAP/XML Transformation** | ‚ùå | ‚ùå | ‚úÖ | Bridge adapta SOAP |
| **mTLS/ICP-Brasil** | ‚ùå | ‚ùå | ‚úÖ | Bridge lida com Bacen |
| **Assinatura Digital XML** | ‚ùå | ‚ùå | ‚úÖ | Bridge assina com A3 |
| **Chamada HTTPS para Bacen** | ‚ùå | ‚ùå | ‚úÖ | Bridge executa HTTP |

---

## üéØ DECIS√ïES ARQUITETURAIS CR√çTICAS

### Decis√£o 1: ClaimWorkflow no Core-Dict ‚úÖ

**Contexto**: Claim √© processo de neg√≥cio de 7-30 dias com decis√µes complexas.

**Decis√£o**: ClaimWorkflow Temporal vive no **Core-Dict**.

**Raz√µes**:
1. **L√≥gica de Neg√≥cio Complexa**:
   - Valida√ß√£o de propriedade (hist√≥rico transacional)
   - Detec√ß√£o de fraude (integra√ß√£o Fraud Detection Service)
   - Decis√µes baseadas em contexto (perfil usu√°rio, hist√≥rico)

2. **Orquestra√ß√£o Multi-Servi√ßo**:
   - Core-Dict orquestra: Notification Service, Fraud Service, User Service
   - Conn-Dict n√£o tem acesso a esses servi√ßos

3. **State Management Rico**:
   - Claim tem estado complexo (history, logs, attachments)
   - Core-Dict PostgreSQL mant√©m esse estado

4. **Compliance Bacen**:
   - Core-Dict gera audit logs regulat√≥rios
   - Core-Dict rastreia compliance

**Alternativa Rejeitada**: ClaimWorkflow no Conn-Dict
- ‚ùå Conn-Dict n√£o tem contexto de neg√≥cio
- ‚ùå Conn-Dict n√£o acessa outros dom√≠nios
- ‚ùå Violaria Separation of Concerns

---

### Decis√£o 2: BridgeCallActivity no Conn-Dict ‚úÖ

**Contexto**: Retry t√©cnico de chamadas HTTP ao Bridge.

**Decis√£o**: BridgeCallActivity Temporal vive no **Conn-Dict**.

**Raz√µes**:
1. **Concern T√©cnico de Infraestrutura**:
   - Retry n√£o depende de l√≥gica de neg√≥cio
   - √â transparente para Core-Dict

2. **Reutiliz√°vel**:
   - Mesma l√≥gica de retry para todas as chamadas
   - Core-Dict n√£o precisa saber de retry HTTP

3. **Connection Pool**:
   - Conn-Dict gerencia pool de conex√µes ao Bridge
   - Retry deve usar o mesmo pool

**Alternativa Rejeitada**: BridgeCallActivity no Core-Dict
- ‚ùå Core-Dict n√£o deveria gerenciar retry HTTP
- ‚ùå Violaria Separation of Concerns

---

### Decis√£o 3: Balde de Conex√µes Bacen no Conn-Dict ‚úÖ

**Contexto**: Bacen tem rate limit (1000 TPS). Precisa gerenciar pool de conex√µes.

**Decis√£o**: Connection Pool Management no **Conn-Dict**.

**Raz√µes**:
1. **Infraestrutura T√©cnica**:
   - Rate limiting √© concern t√©cnico, n√£o de neg√≥cio
   - Core-Dict n√£o deve saber de TPS limits

2. **Transpar√™ncia**:
   - Core-Dict chama ConnectService normalmente
   - Conn-Dict gerencia pool internamente

3. **Resili√™ncia**:
   - Conn-Dict implementa circuit breaker
   - Conn-Dict faz retry com backoff
   - Core-Dict recebe erro ou sucesso

**Implementa√ß√£o**:
```go
// CONN-DICT: Connection Pool
type BridgeConnectionPool struct {
    connections []*grpc.ClientConn
    maxConn     int // Bacen rate limit: 1000 TPS
    semaphore   chan struct{}
}

func (p *BridgeConnectionPool) AcquireConnection() (*grpc.ClientConn, error) {
    // Wait for available slot (rate limiting)
    select {
    case p.semaphore <- struct{}{}:
        return p.getHealthyConnection(), nil
    case <-time.After(5 * time.Second):
        return nil, ErrConnectionPoolExhausted
    }
}

func (p *BridgeConnectionPool) ReleaseConnection() {
    <-p.semaphore
}
```

**Alternativa Rejeitada**: Connection Pool no Core-Dict
- ‚ùå Core-Dict n√£o deveria gerenciar rate limiting
- ‚ùå Violaria Separation of Concerns

---

## üìê ARQUITETURA FINAL VALIDADA

### Fluxo Completo: CreateClaim

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    FLUXO COMPLETO                            ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                               ‚îÇ
‚îÇ  1. Frontend ‚Üí Core-Dict REST API                            ‚îÇ
‚îÇ     POST /claims                                             ‚îÇ
‚îÇ     ‚Üì                                                         ‚îÇ
‚îÇ  2. CORE-DICT (Business Layer)                               ‚îÇ
‚îÇ     ‚îú‚îÄ Valida√ß√µes de neg√≥cio ‚úÖ                              ‚îÇ
‚îÇ     ‚îÇ  ‚îú‚îÄ Limite de claims (max 3)                           ‚îÇ
‚îÇ     ‚îÇ  ‚îú‚îÄ Valida√ß√£o de propriedade                           ‚îÇ
‚îÇ     ‚îÇ  ‚îî‚îÄ Anti-fraude (FraudService)                         ‚îÇ
‚îÇ     ‚îÇ                                                         ‚îÇ
‚îÇ     ‚îú‚îÄ Iniciar ClaimWorkflow Temporal ‚úÖ                     ‚îÇ
‚îÇ     ‚îÇ  ‚îú‚îÄ CreateClaim (state)                                ‚îÇ
‚îÇ     ‚îÇ  ‚îú‚îÄ NotifyOwner (business process)                     ‚îÇ
‚îÇ     ‚îÇ  ‚îú‚îÄ WaitTimer(7 dias) (business rule)                  ‚îÇ
‚îÇ     ‚îÇ  ‚îú‚îÄ DecideClaim (business logic)                       ‚îÇ
‚îÇ     ‚îÇ  ‚îî‚îÄ CallConnectActivity ‚Üê AQUI chama infra             ‚îÇ
‚îÇ     ‚îÇ     ‚Üì                                                   ‚îÇ
‚îÇ  3. CONN-DICT (Integration Layer)                            ‚îÇ
‚îÇ     ‚îú‚îÄ Connection Pool (acquire) ‚úÖ                          ‚îÇ
‚îÇ     ‚îú‚îÄ Circuit Breaker (check) ‚úÖ                            ‚îÇ
‚îÇ     ‚îú‚îÄ Transforma√ß√£o proto (Core ‚Üí Bridge) ‚úÖ                ‚îÇ
‚îÇ     ‚îú‚îÄ gRPC call to Bridge ‚úÖ                                ‚îÇ
‚îÇ     ‚îî‚îÄ Retry dur√°vel (se falhar) ‚úÖ                          ‚îÇ
‚îÇ        ‚Üì                                                      ‚îÇ
‚îÇ  4. CONN-BRIDGE (Protocol Adapter)                           ‚îÇ
‚îÇ     ‚îú‚îÄ Proto ‚Üí XML ‚úÖ                                         ‚îÇ
‚îÇ     ‚îú‚îÄ XML ‚Üí SOAP envelope ‚úÖ                                ‚îÇ
‚îÇ     ‚îú‚îÄ Assinar XML (ICP-Brasil A3) ‚úÖ                        ‚îÇ
‚îÇ     ‚îú‚îÄ POST HTTPS + mTLS para Bacen ‚úÖ                       ‚îÇ
‚îÇ     ‚îî‚îÄ Parse SOAP response ‚úÖ                                ‚îÇ
‚îÇ        ‚Üì                                                      ‚îÇ
‚îÇ  5. Bacen DICT API                                           ‚îÇ
‚îÇ     ‚úÖ Claim criado no DICT                                  ‚îÇ
‚îÇ        ‚Üì                                                      ‚îÇ
‚îÇ  6. Response volta (Bridge ‚Üí Connect ‚Üí Core ‚Üí Frontend)     ‚îÇ
‚îÇ                                                               ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Separa√ß√£o Clara**:
- **Core-Dict**: Business logic, workflows complexos, decis√µes
- **Conn-Dict**: Connection management, retry, circuit breaker, protocol adaptation
- **Conn-Bridge**: SOAP/XML transformation, mTLS, Bacen API calls

---

## üéì CONCLUS√ÉO

### Resposta √† Pergunta Original

> **"Workflows de neg√≥cio complexos (como Reivindica√ß√µes) devem estar no Core-Dict ou Conn-Dict?"**

### ‚úÖ RESPOSTA: CORE-DICT

**Workflows de neg√≥cio (ClaimWorkflow, PortabilityWorkflow) ‚Üí CORE-DICT**
- L√≥gica de neg√≥cio complexa
- Decis√µes baseadas em contexto
- Orquestra√ß√£o multi-servi√ßo
- Valida√ß√µes de dom√≠nio
- Compliance Bacen

**Infraestrutura t√©cnica (Connection Pool, Retry, Circuit Breaker) ‚Üí CONN-DICT**
- Gerenciamento de conex√µes
- Rate limiting Bacen
- Retry dur√°vel t√©cnico
- Circuit breaker
- Transforma√ß√£o de protocolos

---

### Princ√≠pio Arquitetural Fundamental

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ             REGRA DE OURO (Golden Rule)                      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                               ‚îÇ
‚îÇ  "Se a l√≥gica precisa de CONTEXTO DE NEG√ìCIO para decidir,  ‚îÇ
‚îÇ   ela pertence ao CORE-DICT."                                ‚îÇ
‚îÇ                                                               ‚îÇ
‚îÇ  "Se a l√≥gica √© INFRAESTRUTURA T√âCNICA reutiliz√°vel,        ‚îÇ
‚îÇ   ela pertence ao CONN-DICT."                                ‚îÇ
‚îÇ                                                               ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

**√öltima Atualiza√ß√£o**: 2025-10-27 18:30 BRT
**Arquiteto**: Claude Sonnet 4.5
**Status**: ‚úÖ ARQUITETURA VALIDADA E APROVADA
**Conformidade**: DDD, Hexagonal Architecture, Separation of Concerns
